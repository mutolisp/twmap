#' Plot Species Distribution Map with Vertical Profile
#'
#' This function generates a map displaying species distribution points (x, y) 
#' and their corresponding elevation profiles (y, z). It uses Base R graphics.
#'
#' @param pts A data frame or list with three columns: x (longitude), y (latitude), and z (elevation).
#' @param boundary Character. File path or name of the boundary shapefile (to be loaded as an sf object).
#' @param col Character or vector of characters. Color(s) used for plotting the species points. Default is "black".
#' @param vert_prof A data frame or list containing the island's elevation profile data 
#'                  (typically generated by a function like `lat_elev_profile`).
#' @param cex Numeric. Magnification factor for plotting symbols. Default is 0.3.
#' @param pch Numeric. Plotting character used for points. Default is 19 (solid circle).
#'
#' @return The function is used for its side effect (plotting) and returns \code{NULL} invisibly.
#' @export
#'
#' @importFrom graphics abline axis box lines par segments text plot.xy
#' @importFrom grDevices xy.coords
#' @importFrom sf st_read st_bbox
#'
#' @examples
#' \dontrun{
#' # Assuming the package name is 'twmap' and files are in inst/extdata
#' # Get the path for the boundary shapefile (LanyuBorder.shp)
#' boundary_path <- system.file("extdata", "LanyuBorder.shp", package = "twmap")
#' 
#' # Generate the elevation profile data using the GeoTIFF (LanyuDTM.tif)
#' # Note: lat_elev_profile is assumed to be an existing function in your package
#' profile_data <- lat_elev_profile(system.file("extdata", "LanyuDTM.tif", package = "twmap"))
#' 
#' # Load example species points data
#' data("sample_spts.ly") 
#' 
#' # Plot the map
#' distrmap(sample_spts.ly, 
#'          boundary = boundary_path, 
#'          vert_prof = profile_data, 
#'          col = "blue")
#' }
#' 
distrmap <- function (pts,
                      boundary,
                      col = "black",
                      vert_prof,
                      cex = 0.3,
                      pch = 19) {
  
  basemap <- function (boundary, vert_prof) {
    
    custom_sf <- sf::st_read(boundary, quiet = TRUE)
    bbox <- sf::st_bbox(custom_sf)
    
    x_range <- bbox["xmax"] - bbox["xmin"]
    y_range <- bbox["ymax"] - bbox["ymin"]
    
    # ----------------------------------------------------
    # 1. Dynamic Calculation of Boundaries and Padding
    # ----------------------------------------------------
    
    # 1.1 Set Padding (Margins)
    x_pad_map <- x_range * 0.05
    y_pad_map <- y_range * 0.05
    

    y_pad_bottom <- base::max(y_pad_map, y_range * 0.1)
    y_pad_top <- y_pad_map
    
    # 1.2 Set vertical profile width (X-axis length)
    vert_prof_width <- x_range * 0.25 
    
    # 1.3 Set starting longitude for vertical profile (vert_bound)
    vert_prof_gap <- x_pad_map * 0.5 
    vert_bound <- bbox["xmax"] + x_pad_map + vert_prof_gap 
    
    # 1.4 Recalculate total plotting area xlim and ylim
    x_pad_label <- vert_prof_width * 0.02
    
    xlim <- c(bbox["xmin"] - x_pad_map, vert_bound + vert_prof_width + x_pad_label)
    ylim <- c(bbox["ymin"] - y_pad_bottom, bbox["ymax"] + y_pad_top)
    
    ly <- ylim[1]
    uy <- ylim[2]
    
    # ----------------------------------------------------
    # Calculate Elevation Limits (4-stage)
    # ----------------------------------------------------
    max_elev <- base::max(vert_prof$z, na.rm = TRUE)
    
    if (max_elev <= 1000) {
      if (max_elev <= 100) {
        elev_limit <- 100
      } else if (max_elev <= 250) {
        elev_limit <- 250
      } else if (max_elev <= 500) {
        elev_limit <- 500
      } else {
        elev_limit <- 1000
      }
    } else {
      elev_limit <- base::ceiling(max_elev / 1000) * 1000
    }
    
    custom_coords <- sf::st_coordinates(custom_sf)
    
    # ----------------------------------------------------
    # 2. Draw Map Area
    # ----------------------------------------------------
    
    graphics::plot(
      NA, xlim = xlim, ylim = ylim, axes = FALSE, xlab = "", ylab = "", asp = 1
    )
    
    graphics::polygon(
      custom_coords[, "X"], custom_coords[, "Y"], col = "white", border = "#aaaaaa"
    )
    
    # Latitude axis (Left side)
    grid_lat <- base::pretty(ylim, n = 3)
    grid_lat <- grid_lat[grid_lat >= ylim[1] & grid_lat <= ylim[2]]
    axis_latlab <- base::parse(text = base::paste(grid_lat, "*degree~", "N", sep = ""))
    graphics::axis(side = 2, lwd = 0.8, labels = axis_latlab , 
                   lwd.ticks = 0.5, at = grid_lat, cex = 0.8)
    
    # Longitude axis (Bottom)
    # Only display longitude axis within the map range
    grid_long <- base::pretty(c(bbox["xmin"], bbox["xmax"]), n = 3)
    grid_long <- grid_long[grid_long >= xlim[1] & grid_long <= xlim[2]]
    axis_longlab <- base::parse(text = base::paste(grid_long, "*degree~", "E", sep = ""))
    graphics::axis(side = 1, labels = axis_longlab, at = grid_long, 
                   line = NA, lwd = 0.8, cex = 0.8)
    
    # ----------------------------------------------------
    # 3. Draw Vertical Profile Area
    # ----------------------------------------------------
    
    graphics::par(new = TRUE)
    
    # Draw profile plot boundary (uses bbox["ymin"] as the actual bottom line)
    graphics::segments(vert_bound, ly + y_pad_map / 2, vert_bound, uy) 
    graphics::segments(vert_bound, ly + y_pad_map / 2, vert_bound + vert_prof_width, ly + y_pad_map / 2) 
    
    # Dynamic elevation axis and grid
    num_ticks <- 4 # Number of intervals for elevation axis
    for (i in 0:num_ticks) {
      current_elev <- (i / num_ticks) * elev_limit
      x_pos <- vert_bound + (current_elev / elev_limit) * vert_prof_width 
      
      if (i > 0) {
        # Draw vertical grid lines covering the main map area
        graphics::segments(x_pos, ly + y_pad_map / 2, x_pos, uy, col = 'grey', lty = 1)
      }
      
      # Draw tick marks and labels
      graphics::segments(x_pos, ly + y_pad_map / 2, x_pos, ly + y_pad_map / 2)
      ticlab <- base::paste0(current_elev)
      lat_unit <- base::abs(grid_lat[2] - grid_lat[1])
      graphics::text(x_pos, ly, ticlab, cex = 0.7)
    }
    
    label_x_pos <- vert_bound + (vert_prof_width / 2)
    graphics::text(label_x_pos, ly - lat_unit / 20, 'Elevation (m)', cex = 0.8)
    
    # Draw elevation profile line
    # Map elevation (z) to the profile's X-axis
    vert_prof$x_map <- vert_bound + (vert_prof$z / elev_limit) * vert_prof_width 
    vf <- base::cbind(vert_prof$x_map, vert_prof$y) 
    
    graphics::plot.xy(
      grDevices::xy.coords(vf),
      type = 'p', col = 'white', pch = 19, cex = 0.5
    )
    graphics::lines(vf, col = 'darkgrey')
    
    # Note: Right-side latitude axis (side=4) is commented out/removed.
    # graphics::axis(
    #   side = 4,
    #   lwd = 0.8,
    #   labels = axis_latlab,
    #   lwd.ticks = 0.5,
    #   at = grid_lat,
    #   cex = 0.8
    # )
    
    graphics::box()
    
    # Return dynamic parameters for point plotting
    return(list(vert_bound = vert_bound, 
                elev_limit = elev_limit,
                vert_prof_width = vert_prof_width))
  }
  
  # --- draw_sp_pts --- function plots species points on both map and profile.
  draw_sp_pts <- function(pts, col, cex, pch, vert_bound, elev_limit, vert_prof_width) { 
    
    if (base::dim(pts)[2] != 3) {
      base::print('The input points should have x (longitude), y (latitude) and z (elevation)')
    } else {
      # 1. Horizontal distribution points (on the map)
      horizon_pts <- base::cbind(x = pts$x, y = pts$y)
      
      graphics::plot.xy(
        grDevices::xy.coords(horizon_pts),
        type = 'p', col = col, pch = pch, cex = cex
      )
      
      # 2. Vertical distribution points (on the profile plot)
      # Map elevation (z) to the profile's X-axis
      pts$x_map <- vert_bound + (pts$z / elev_limit) * vert_prof_width 
      vert_pts <- base::cbind(x_map = pts$x_map, y = pts$y)
      
      graphics::plot.xy(
        grDevices::xy.coords(vert_pts),
        type = 'p', col = col, pch = pch, cex = cex
      )
    }
  }
  
  # --- Main Call ---
  dynamic_params <- basemap(boundary, vert_prof)
  draw_sp_pts(pts, col, cex, pch, 
              vert_bound = dynamic_params$vert_bound, 
              elev_limit = dynamic_params$elev_limit,
              vert_prof_width = dynamic_params$vert_prof_width)
}
